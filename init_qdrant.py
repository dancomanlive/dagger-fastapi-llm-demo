#!/usr/bin/env python3
"""
Utility script to initialize Qdrant with test data for the RAG pipeline,
using qdrant-client's fastembed for embedding generation.
"""
import json
import argparse
import os
import sys
from qdrant_client import QdrantClient, models as qdrant_models
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Default Qdrant connection settings
# For this script, which might run on the host, we usually target localhost or a specific IP.
# If running this script INSIDE a Docker container that's part of the same docker-compose,
# then 'http://qdrant:6333' would be correct.
# Since this is likely run from the host for initialization, let's make it configurable.
DEFAULT_QDRANT_URL = os.environ.get("http://localhost:6333")
DEFAULT_COLLECTION = os.environ.get("QDRANT_COLLECTION_NAME", "default") # Align with Dagger pipeline's default

# Default embedding model to be used by fastembed (via qdrant-client)
DEFAULT_EMBEDDING_MODEL = os.environ.get("EMBEDDING_MODEL", "sentence-transformers/all-MiniLM-L6-v2")

# This is the field name in Qdrant payload where the main text content will be stored.
# Needs to match what the retriever script (modules/retrieve/main.py) expects (PAYLOAD_TEXT_FIELD_NAME).
# The qdrant_demo used 'document'. Let's align with that.
TEXT_FIELD_NAME_FOR_PAYLOAD = "document"


# Sample RAG documents
SAMPLE_DOCUMENTS_PAYLOAD = [
    {
        "id_str": "1", # Keep original string ID for payload if needed, will convert to int for Qdrant point ID
        TEXT_FIELD_NAME_FOR_PAYLOAD: "Retrieval-Augmented Generation (RAG) is a technique that combines retrieval-based and generation-based approaches for NLP tasks. It retrieves relevant documents from a corpus and uses them to augment the input of a text generation model.",
        "source": "wikipedia", "domain": "ai" # Example metadata fields
    },
    {
        "id_str": "2",
        TEXT_FIELD_NAME_FOR_PAYLOAD: "RAG works by first embedding a query, then using vector similarity search to find relevant documents in a vector database. These documents provide context that improves the quality and factuality of generated responses.",
        "source": "textbook", "domain": "ai"
    },
    {
        "id_str": "3",
        TEXT_FIELD_NAME_FOR_PAYLOAD: "The key components of a RAG system include: a vector database for storing embeddings, a retriever for finding relevant documents, and a generator (usually an LLM) that produces responses based on the retrieved context.",
        "source": "blog", "domain": "ai"
    },
    {
        "id_str": "4",
        TEXT_FIELD_NAME_FOR_PAYLOAD: "RAG helps solve common LLM problems like hallucinations by grounding generation in retrieved facts. It also enables models to access knowledge beyond their training data without requiring constant retraining.",
        "source": "research_paper", "domain": "ai"
    },
    {
        "id_str": "5",
        TEXT_FIELD_NAME_FOR_PAYLOAD: "Modularity in RAG architectures allows different components to be swapped or upgraded. For example, using different embedding models, vector databases, or LLMs without completely rebuilding the system.",
        "source": "documentation", "domain": "ai"
    }
]

def initialize_qdrant(qdrant_url: str, collection_name: str, documents_payload: list, embedding_model_name: str):
    """
    Initialize Qdrant with sample documents.
    Embeddings are generated by qdrant-client using fastembed.
    """
    qdrant_api_key = os.getenv("QDRANT_API_KEY")
    client_args = {"url": qdrant_url, "prefer_grpc": True}
    if qdrant_api_key:
        print("Using QDRANT_API_KEY for Qdrant connection.")
        client_args["api_key"] = qdrant_api_key
    else:
        print("No QDRANT_API_KEY found. Connecting to Qdrant without API key.")

    try:
        client = QdrantClient(**client_args)
        print(f"Successfully connected to Qdrant at {qdrant_url}")
    except Exception as e:
        print(f"Error: Could not connect to Qdrant at {qdrant_url}. Exception: {e}", file=sys.stderr)
        print("Please ensure Qdrant is running and accessible.", file=sys.stderr)
        return False

    # Get vector size from the client using the specified model
    try:
        vector_size = client.get_embedding_size(embedding_model_name)
        print(f"Determined vector size for model '{embedding_model_name}': {vector_size}")
    except Exception as e:
        print(f"Error: Could not determine vector size for model '{embedding_model_name}'. Exception: {e}", file=sys.stderr)
        print(f"Make sure the model name is correct and qdrant-client[fastembed] is installed.", file=sys.stderr)
        return False

    # Check if collection exists and recreate it
    try:
        existing_collections = client.get_collections().collections
        collection_names = [c.name for c in existing_collections]
        if collection_name in collection_names:
            print(f"Collection '{collection_name}' already exists. Recreating...")
            client.delete_collection(collection_name)
    except Exception as e:
        print(f"Error checking or deleting collection '{collection_name}': {e}", file=sys.stderr)
        return False

    try:
        print(f"Creating collection '{collection_name}' with vector size {vector_size}...")
        client.create_collection(
            collection_name=collection_name,
            vectors_config=qdrant_models.VectorParams(
                size=vector_size,
                distance=qdrant_models.Distance.COSINE
            ),
            # Optional: Add quantization like in the qdrant_demo example
            quantization_config=qdrant_models.ScalarQuantization(
                scalar=qdrant_models.ScalarQuantizationConfig(
                    type=qdrant_models.ScalarType.INT8,
                    quantile=0.99,
                    always_ram=False # Set to False for on-disk, True if you want it in RAM
                )
            )
        )
        print(f"Collection '{collection_name}' created successfully.")

        # Create a payload index for the text field to enable full-text search (optional but good for hybrid)
        client.create_payload_index(
            collection_name=collection_name,
            field_name=TEXT_FIELD_NAME_FOR_PAYLOAD,
            field_schema=qdrant_models.TextIndexParams(
                type=qdrant_models.TextIndexType.TEXT,
                tokenizer=qdrant_models.TokenizerType.WORD,
                min_token_len=2,
                max_token_len=20,
                lowercase=True,
            )
        )
        print(f"Payload index created for field '{TEXT_FIELD_NAME_FOR_PAYLOAD}'.")

    except Exception as e:
        print(f"Error creating collection or payload index '{collection_name}': {e}", file=sys.stderr)
        return False

    # Prepare points for upsert.
    # qdrant-client will generate embeddings from the `models.Document` object.
    points_to_upload = []
    for i, doc_payload in enumerate(documents_payload):
        # Qdrant point IDs can be integers or UUIDs. Using integers from 'id_str'.
        point_id = int(doc_payload["id_str"])

        # The text to be embedded is in the field named by TEXT_FIELD_NAME_FOR_PAYLOAD
        text_to_embed = doc_payload.get(TEXT_FIELD_NAME_FOR_PAYLOAD)
        if not text_to_embed:
            print(f"Warning: Document with id_str '{doc_payload['id_str']}' has no text in field '{TEXT_FIELD_NAME_FOR_PAYLOAD}'. Skipping.", file=sys.stderr)
            continue
            
        # The payload should contain all metadata you want to store.
        # We already have TEXT_FIELD_NAME_FOR_PAYLOAD in doc_payload.
        # We can exclude 'id_str' if we don't need it in the payload itself.
        payload_for_qdrant = {k: v for k, v in doc_payload.items() if k != "id_str"}

        points_to_upload.append(
            qdrant_models.PointStruct(
                id=point_id,
                vector=qdrant_models.Document( # Instructs qdrant-client to embed this
                    text=text_to_embed,
                    model=embedding_model_name
                ),
                payload=payload_for_qdrant
            )
        )

    if not points_to_upload:
        print("No valid documents to upload after processing.", file=sys.stderr)
        return False

    try:
        print(f"Uploading {len(points_to_upload)} points to collection '{collection_name}'...")
        # Using upload_points for potentially larger datasets, as it handles batching.
        # For small datasets like this, upsert would also work.
        client.upload_points(
            collection_name=collection_name,
            points=points_to_upload,
            parallel=2, # Adjust based on your Qdrant setup and client machine
            batch_size=16 # Good default
        )
        print(f"Successfully initialized collection '{collection_name}' with {len(points_to_upload)} documents.")
        return True
    except Exception as e:
        print(f"Error upserting points to collection '{collection_name}': {e}", file=sys.stderr)
        return False

def main():
    parser = argparse.ArgumentParser(description="Initialize Qdrant with test data for RAG pipeline using qdrant-client/fastembed.")
    parser.add_argument("--qdrant_url", default=DEFAULT_QDRANT_URL, help=f"Qdrant server URL (default: {DEFAULT_QDRANT_URL})")
    parser.add_argument("--collection", default=DEFAULT_COLLECTION, help=f"Collection name (default: {DEFAULT_COLLECTION})")
    parser.add_argument("--model", default=DEFAULT_EMBEDDING_MODEL, help=f"Embedding model name for fastembed (default: {DEFAULT_EMBEDDING_MODEL})")
    args = parser.parse_args()

    print(f"--- Qdrant Initialization Script (using fastembed) ---")
    print(f"Target Qdrant URL: {args.qdrant_url}")
    print(f"Target Collection: {args.collection}")
    print(f"Embedding Model: {args.model}")
    print(f"Text field in payload: '{TEXT_FIELD_NAME_FOR_PAYLOAD}'")

    if not SAMPLE_DOCUMENTS_PAYLOAD:
        print("No sample documents defined. Exiting.", file=sys.stderr)
        sys.exit(1)
    
    success = initialize_qdrant(args.qdrant_url, args.collection, SAMPLE_DOCUMENTS_PAYLOAD, args.model)
    
    if success:
        print("\nQdrant initialization complete!")
        print(f"Collection '{args.collection}' should now be populated and ready.")
    else:
        print("\nQdrant initialization failed. Please check error messages above.")
        sys.exit(1)

if __name__ == "__main__":
    # Ensure qdrant-client with fastembed is installed for this script to run
    # e.g., pip install "qdrant-client[fastembed]>=1.14.0" python-dotenv
    try:
        import qdrant_client.fastembed_common # Check if fastembed extra is likely available
    except ImportError:
        print("Error: qdrant-client with fastembed extra not found.", file=sys.stderr)
        print("Please install it: pip install \"qdrant-client[fastembed]>=1.14.0\"", file=sys.stderr)
        sys.exit(1)
    main()